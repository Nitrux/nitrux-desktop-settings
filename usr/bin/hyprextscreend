#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2024-2025 <Nitrux Latinoamericana S.C. <hello@nxos.org>>


# -- Exit on errors.

set -euo pipefail


# -- Configuration.

CONFIG_FILE="/etc/hyprscreen.conf"


# -- Functions.

load_config() {
  if [ ! -r "$CONFIG_FILE" ]; then
    log "ERR" "Required configuration file not found or is unreadable: $CONFIG_FILE. Exiting."
    exit 1
  fi
  
  log "INFO" "Loading configuration from $CONFIG_FILE"
  
  # shellcheck source=/dev/null
  . "$CONFIG_FILE"

  : "${HYPR_CONFIG:?Required variable HYPR_CONFIG is not set in config file.}"
  : "${EXTERNAL_SCREEN:?Required variable EXTERNAL_SCREEN is not set in config file.}"
  : "${SCALE_FACTOR:?Required variable SCALE_FACTOR is not set in config file.}"
  : "${LOCKFILE:?Required variable LOCKFILE is not set in config file.}"
}

usage() { echo "Usage: $0"; exit 1; }
log() { logger -t hyprextscreend "$1: $2"; }
need() { command -v "$1" >/dev/null 2>&1 || { log "ERR" "$1 not found"; exit 1; }; }

need hyprctl
need jq
need pkill
need nohup

load_config

acquire_lock() {
  while ! mkdir "$LOCKFILE" 2>/dev/null; do
    sleep 0.1
  done
  trap 'release_lock' EXIT INT TERM
}

release_lock() {
  rmdir "$LOCKFILE" 2>/dev/null || true
  trap - EXIT INT TERM
}

pick_mode_for_monitor() {
  name="$1"
  pref="$2"
  hyprctl monitors -j 2>/dev/null | jq -r --arg name "$name" --arg pref "$pref" '
    (map(select(.name==$name)) | .[0]) as $m
    | if $m==null then empty else
      (if ($m.availableModes|type=="array" and ($m.availableModes|length)>0) then
         $m.availableModes
         | map(capture("^(?<w>\\d+)x(?<h>\\d+)@(?<r>[0-9.]+)Hz$")
               | {w:(.w|tonumber), h:(.h|tonumber), r:((.r|tonumber)|floor)})
       else
         ($m.modes
          | map({w:(.width//.w), h:(.height//.h),
                 r:(((.refreshRate//(.refresh//0))//0) as $rr
                    | if $rr>1000 then ($rr/1000|floor) else ($rr|floor) end)}))
       end) as $all
      | ($all | max_by([.w,.h]) | {w,h}) as $maxres
      | ($all | map(select(.w==$maxres.w and .h==$maxres.h))) as $cands
      | (if $pref=="hi" then ($cands|max_by(.r)) else ($cands|min_by(.r)) end) as $pick
      | if $pick==null then empty else "\($pick.w)x\($pick.h)@\($pick.r)" end
    end
  '
}

pick_mode_fixed_hz() {
  name="$1"
  hz="$2"
  hyprctl monitors -j 2>/dev/null | jq -r --arg name "$name" --argjson hz "$hz" '
    (map(select(.name==$name)) | .[0]) as $m
    | if $m==null then empty else
      (if ($m.availableModes|type=="array" and ($m.availableModes|length)>0) then
         $m.availableModes
         | map(capture("^(?<w>\\d+)x(?<h>\\d+)@(?<r>[0-9.]+)Hz$")
               | {w:(.w|tonumber), h:(.h|tonumber), r:((.r|tonumber)|floor)})
       else
         ($m.modes
          | map({w:(.width//.w), h:(.height//.h),
                 r:(((.refreshRate//(.refresh//0))//0) as $rr
                    | if $rr>1000 then ($rr/1000|floor) else ($rr|floor) end)}))
       end) as $all
      | ($all | max_by([.w,.h]) | {w,h}) as $maxres
      | ($all | map(select(.w==$maxres.w and .h==$maxres.h))) as $cands
      | ($cands | map(select(.r==$hz)) | if length>0 then . else $cands end) as $pickset
      | ($pickset | min_by(.r)) as $pick
      | if $pick==null then empty else "\($pick.w)x\($pick.h)@\($pick.r)" end
    end
  '
}

upsert_external_below_edp1() {
  acquire_lock
  mon="$1"
  mode_str="$2"
  scale="$3"
  exact="monitor = $mon, $mode_str, auto, $scale"
  if [ "$mon" = "eDP-1" ]; then
    release_lock
    return 0
  fi
  if grep -Fqx "$exact" "$HYPR_CONFIG" 2>/dev/null; then
    release_lock
    return 0
  fi
  tmp="$(mktemp)"
  awk -v edp="eDP-1" -v mon="$mon" -v newline="$exact" '
    BEGIN {
      gsub(/^[ \t]+|[ \t]+$/, "", newline)
      re_generic="^[ \t]*monitor[ \t]*=[ \t]*,[ \t]*preferred[ \t]*,[ \t]*auto[ \t]*,[ \t]*[0-9.]+"
      re_edp="^[ \t]*monitor[ \t]*=[ \t]*" edp "[ \t]*,"
      re_mon="^[ \t]*monitor[ \t]*=[ \t]*" mon "[ \t]*,"
      did_insert=0
    }
    {
      if ($0 ~ re_generic && $0 !~ /^[ \t]*#/) { print "# " $0; next }
      if ($0 ~ re_edp) { print $0; if (did_insert==0) { print newline; did_insert=1 }; next }
      if ($0 ~ re_mon) { next }
      print
    }
    END {
      if (did_insert==0) print newline
    }
  ' "$HYPR_CONFIG" >"$tmp" && mv -f -- "$tmp" "$HYPR_CONFIG"
  release_lock
  return 0
}

restart_crystal_dock() {
  if command -v crystal-dock >/dev/null 2>&1; then
    pkill -x crystal-dock >/dev/null 2>&1 || true
    nohup crystal-dock >/dev/null 2>&1 &
    disown || true
  fi
}

list_connected_externals() {
  mon_list="${EXTERNAL_SCREEN// /|}"
  
  hyprctl monitors -j 2>/dev/null | jq -r --arg list "$mon_list" '
    map(.name)|.[]|select(test($list))
  '
}

handle_new_external() {
  mon="$1"
  m60="$(pick_mode_fixed_hz "$mon" 60 || true)"
  if [ -n "$m60" ]; then
    if upsert_external_below_edp1 "$mon" "$m60" "$SCALE_FACTOR"; then
      hyprctl reload >/dev/null 2>&1 || true
      restart_crystal_dock
    fi
  fi
  sleep 0.5
  mhi="$(pick_mode_for_monitor "$mon" hi || true)"
  if [ -n "$mhi" ] && [ "$mhi" != "$m60" ]; then
    if upsert_external_below_edp1 "$mon" "$mhi" "$SCALE_FACTOR"; then
      hyprctl reload >/dev/null 2>&1 || true
    fi
  fi
}

watch_externals() {
  prev=""
  while :; do
    curr="$(list_connected_externals | tr '\n' ' ' | sed 's/[[:space:]]\+$//')"
    for m in $curr; do
      echo " $prev " | grep -q " $m " || handle_new_external "$m"
    done
    prev="$curr"
    sleep 1
  done
}


# -- Configure external screens in Hyprland.

log "INFO" "Starting Hyprland external monitor daemon"

watch_externals 
