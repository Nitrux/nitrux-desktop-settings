#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2024-2025 <Nitrux Latinoamericana S.C. <hello@nxos.org>>


# -- Exit on errors.

set -euo pipefail


# -- Configuration.

CONFIG_FILE="/etc/hyprscreen.conf"


# -- Functions.

load_config() {
  if [ ! -r "$CONFIG_FILE" ]; then
    log "ERR" "Required configuration file not found or is unreadable: $CONFIG_FILE. Exiting."
    exit 1
  fi
  
  log "INFO" "Loading configuration from $CONFIG_FILE"
  
  # shellcheck source=/dev/null
  . "$CONFIG_FILE"

  : "${HYPR_CONFIG:?Required variable HYPR_CONFIG is not set in config file.}"
  : "${INTERNAL_SCREEN:?Required variable INTERNAL_SCREEN is not set in config file.}"
  : "${SCALE_FACTOR:?Required variable SCALE_FACTOR is not set in config file.}"
  : "${LOCKFILE:?Required variable LOCKFILE is not set in config file.}"
}

usage() { echo "Usage: $0"; exit 1; }
log() { logger -t hyprscreend "$1: $2"; }
need() { command -v "$1" >/dev/null 2>&1 || { log "ERR" "$1 not found"; exit 1; }; }

need hyprctl
need jq
need upower

load_config

acquire_lock() {
  while ! mkdir "$LOCKFILE" 2>/dev/null; do
    sleep 0.1
  done
  trap 'release_lock' EXIT INT TERM
}

release_lock() {
  rmdir "$LOCKFILE" 2>/dev/null || true
  trap - EXIT INT TERM
}

pick_mode() {
  pref="$1"
  hyprctl monitors -j 2>/dev/null | jq -r --arg name "$INTERNAL_SCREEN" --arg pref "$pref" '
    (map(select(.name==$name)) | .[0]) as $m
    | if $m==null then empty else
      (if ($m.availableModes|type=="array" and ($m.availableModes|length)>0) then
         $m.availableModes
         | map(capture("^(?<w>\\d+)x(?<h>\\d+)@(?<r>[0-9.]+)Hz$")
               | {w:(.w|tonumber), h:(.h|tonumber), r:((.r|tonumber)|floor)})
       else
         ($m.modes
          | map({w:(.width//.w), h:(.height//.h),
                 r:(((.refreshRate//.refresh)//0) as $rr
                    | if $rr>1000 then ($rr/1000|floor) else ($rr|floor) end)}))
       end) as $all
      | ([$all[] | select(.r>0)]) as $valid
      | (if ($valid|length)>0 then $valid else $all end) as $cand
      | ($cand | max_by([.w,.h]) | {w,h}) as $maxres
      | ($cand | map(select(.w==$maxres.w and .h==$maxres.h)))
      | (if $pref=="hi" then max_by(.r) else min_by(.r) end) as $pick
      | "\($pick.w)x\($pick.h)@\($pick.r)"
    end
  '
}

upsert_config_line() {
  acquire_lock
  mode_str="$1"
  scale="$2"
  exact="monitor = $INTERNAL_SCREEN, $mode_str, auto, $scale"
  if grep -Fqx "$exact" "$HYPR_CONFIG" 2>/dev/null;
  then
    release_lock
    return 1
  fi
  tmp="$(mktemp)"
  awk -v name="$INTERNAL_SCREEN" -v newline="$exact" '
    BEGIN {
      gsub(/^[ \t]+|[ \t]+$/, "", newline);
      re_generic="^[ \t]*monitor[ \t]*=[ \t]*,[ \t]*preferred[ \t]*,[ \t]*auto[ \t]*,[ \t]*[0-9.]+"
      re_monitor="^[ \t]*monitor[ \t]*=[ \t]*" name "[ \t]*,";
      did_replace=0
    }
    {
      if ($0 ~ re_generic && $0 !~ /^[ \t]*#/) { 
        print "# " $0;
        print newline;
        did_replace=1;
        next
      }

      if ($0 ~ re_monitor) { 
        if (did_replace==0) { print newline; did_replace=1 } ; 
        next 
      }

      print
    }
    END { if (did_replace==0) print newline }
  ' "$HYPR_CONFIG" >"$tmp" && mv -f -- "$tmp" "$HYPR_CONFIG"
  release_lock
  return 0
}

apply_ac() {
  m=""
  if ! m="$(pick_mode hi 2>/dev/null)"; then m=""; fi
  [ -n "$m" ] || { log "AC" "no valid mode"; return 1; }
  if upsert_config_line "$m" "$SCALE_FACTOR"; then
    hyprctl reload >/dev/null 2>&1 || true
    log "AC" "applied $m, scale $SCALE_FACTOR"
    return 0
  fi
  return 1
}

apply_battery() {
  m=""
  if ! m="$(pick_mode lo 2>/dev/null)"; then m=""; fi
  [ -n "$m" ] || { log "BAT" "no valid mode"; return 1; }
  if upsert_config_line "$m" "$SCALE_FACTOR"; then
    hyprctl reload >/dev/null 2>&1 || true
    log "BAT" "applied $m, scale $SCALE_FACTOR"
    return 0
  fi
  return 1
}

sysfs_state() {
  any=0
  seen=0
  for d in /sys/class/power_supply/*; do
    [ -d "$d" ] || continue
    seen=1
    t="$(cat "$d/type" 2>/dev/null || echo)"
    case "$t" in
      Mains|USB|USB_C|USB_PD|AC) ;;
      *) continue ;;
    esac
    if [ -r "$d/online" ]; then
      v="$(cat "$d/online" 2>/dev/null || echo 0)"
      [ "$v" = "1" ] && { any=1; break; }
    fi
  done
  if [ "$any" = "1" ]; then
    echo ac
  elif [ "$seen" = "1" ]; then
    echo battery
  else
    echo unknown
  fi
}

upower_state() {
  dev="$(upower -e 2>/dev/null | awk '/DisplayDevice/{print; exit}')"
  [ -n "$dev" ] || { echo unknown; return; }
  s="$(upower -i "$dev" 2>/dev/null | awk -F': *' '/on-battery:/ {print $2; exit}')"
  case "$s" in
    yes) echo battery ;;
    no) echo ac ;;
    *) echo unknown ;;
  esac
}

current_state() {
  s="$(sysfs_state)"
  [ "$s" != "unknown" ] && { echo "$s"; return; }
  s="$(upower_state)"
  [ "$s" != "unknown" ] && { echo "$s"; return; }
  echo unknown
}

wait_for_state() {
  tries=20
  while :; do
    s="$(current_state)"
    [ "$s" != "unknown" ] && { echo "$s"; return; }
    tries=$((tries-1))
    [ "$tries" -le 0 ] && { echo battery; return; }
    sleep 0.2
  done
}

apply_state() {
  case "$1" in
    ac) apply_ac ;;
    battery) apply_battery ;;
    *) return 1 ;;
  esac
}


# -- Change refresh rate of internal screen depending on the power source.

(
  log "INFO" "Starting Hyprland screen refresh rate daemon"

  state="$(wait_for_state)"
  apply_state "$state" || true
  upower --monitor-detail | while IFS= read -r line;
  do
    case "$line" in
      *"on-battery:"*"yes"*) new="battery" ;;
      *"on-battery:"*"no"*)  new="ac" ;;
      *) continue ;;
    esac
    [ "$new" = "$state" ] && continue
    state="$new"
    apply_state "$state" || true
  done
) &
